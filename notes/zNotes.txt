zNotes

Total candies: 20 and 51 on 2 toons. 11:55pm

cd "/c/Users/kirkp/AppData/Roaming/Adventure Land/autosync4984500319158272/adventureland"

cd ~/AppData/Roaming/Adventure\ Land/autosync4984500319158272/adventureland
yarn add --dev jest

parapohrase an error:
Steam Ticket Failed: Error on getting encrypted app ticket.


Screeps People: Rising

https://screeps.com/a/#!/rank/world/2017-09?page=21&highlight=206
https://screeps.com/a/#!/profile/Rising


TODO: Investigate GAME APIs 
- http://adventure.land/docs/code/functions/command_character
- http://adventure.land/docs/code/functions/get_active_characters

****
send_item("Terranger",0,10000);
send_item("Terazarrior",0,10000);
send_item("NoHeals4U",0,10000);
send_item("Terakazam",0,10000);
send_item("Terrogue",0,10000);;

***



== BANK SORT EXAMPLE
Source: "number_e"
https://discord.com/channels/238332476743745536/243707345887166465/742928485294800956

const order = {}
al_items.order = order;

order.names = [
  "Helmets",
  "Armors",
  "Underarmors",
  "Gloves",
  "Shoes",
  "Capes",
  "Rings",
  "Earrings",
  "Amulets",
  "Belts",
  "Orbs",
  "Weapons",
  "Shields",
  "Offhands",
  "Elixirs",
  "Potions",
  "Scrolls",
  "Crafting and Collecting",
  "Exchangeables",
  "Others"
];
order.ids = [
  "helmet",
  "chest",
  "pants",
  "gloves",
  "shoes",
  "cape",
  "ring",
  "earring",
  "amulet",
  "belt",
  "orb",
  "weapon",
  "shield",
  "offhand",
  "elixir",
  "pot",
  "scroll",
  "material",
  "exchange",
  ""
];
order.item_ids = order.ids.map(_id=>[]);
object_sort(G.items, "gold_value").forEach(function(b) {
  if (!b[1].ignore)
    for (var c = 0; c < order.ids.length; c++)
      if (!order.ids[c] || b[1].type == order.ids[c] || "offhand" == order.ids[c] && in_arr(b[1].type, ["source", "quiver", "misc_offhand"]) || "scroll" == order.ids[c] && in_arr(b[1].type, ["cscroll", "uscroll", "pscroll", "offering"]) || "exchange" == order.ids[c] && G.items[b[0]].e) {
        order.item_ids[c].push(b[0]);
        break
      }
});
order.flat_iids = order.item_ids.flat();
order.comparator = function(a,b) {
  return ((a==null)-(b==null)) || (a!=null)&&
  (order.flat_iids.indexOf(a.name)-order.flat_iids.indexOf(b.name)|| 
  (a.name < b.name && -1 || +(a.name > b.name)) || (b.level-a.level));
}

function sort_all_bank(inv_indices, sorted_bank, i_running)
{
  if(!character.bank) return log("Not inside the bank");
  if(!inv_indices)
  {
    inv_indices = []
    for(let i = 0; i < 42; i++)
    {
      if(!character.items[i])
        inv_indices.push(i);
    }
  }
  if(inv_indices.length == 0) return log("Make some space in inventory");
  if(!sorted_bank)
  {
    let bank_array = [];
    for(let bank_pack in character.bank)
    {
      if(bank_pack == "gold") continue;
      bank_array = bank_array.concat(character.bank[bank_pack]);
    }
    bank_array.sort(al_items.order.comparator);
    sorted_bank={};
    for(let bank_pack in character.bank)
    {
      if(bank_pack == "gold") continue;
      sorted_bank[bank_pack] = bank_array.slice(0,42);
      bank_array = bank_array.slice(42);
    }
  }
  if(i_running == null)
    i_running = 0;
  else
    i_running = (i_running + 1) % inv_indices.length;
  const inv_pointer = inv_indices[i_running];
  const inv_itm = character.items[inv_pointer];
  //check every 
  if(!inv_itm)
  {
    for(let bank_pack in character.bank)
    {
      if(bank_pack == "gold") continue;
      for(let i = 0; i < 42; i++)
      {
        if(character.bank[bank_pack][i] && al_items.order.comparator(character.bank[bank_pack][i],sorted_bank[bank_pack][i]))
        {
          log("Swapping empty "+inv_pointer+" with "+i+bank_pack);
          parent.socket.emit("bank",{operation:"swap",pack:bank_pack,str:i,inv:inv_pointer});
          return Sleep(150).then(x=>sort_all_bank(inv_indices,sorted_bank,i_running));
        }
      }

    }
    inv_indices.splice(i_running,1);
    return Sleep(150).then(x=>sort_all_bank(inv_indices,sorted_bank,i_running));

    //good to go. slice off this party of shit and go on
  }
  else
  {
    for(let bank_pack in character.bank)
    {
      if(bank_pack == "gold") continue;
      for(let i = 0; i < 42; i++)
      {
        if(!al_items.order.comparator(inv_itm,sorted_bank[bank_pack][i]) && al_items.order.comparator(character.bank[bank_pack][i],sorted_bank[bank_pack][i]))
        {
          log({operation:"swap",pack:bank_pack,str:i,inv:inv_pointer});
          parent.socket.emit("bank",{operation:"swap",inv:inv_pointer,pack:bank_pack,str:i});
          return Sleep(150).then(x=>sort_all_bank(inv_indices,sorted_bank,i_running));
        }
      }
    }
  }

  //if is empty pull misplaced item
  //else if is full place misplaced item
  return sorted_bank;
}

== END BANK SORT EXAMPLE
==

function findAllCharacters() {
    
}
export function showCoop()
{
    const chars = [character, ...findAllCharacters()];
    const result = [];

    for (let i = 0; i < chars.length; i++) {
        if (!chars[i].s.coop) {
            continue;
        }

        result.push([chars[i].id, chars[i].s.coop.p]);
    }

    result.sort((a, b) => {
        if (a[1] > b[1]) {
            return -1;
        }
        if (a[1] < b[1]) {
            return 1;
        }

        return 0;
    });

    let total = 0;
    for (let i = 0; i < result.length; i++) {
        total += result[i][1];
    }

    let myContribution = 0;

    const objectResult = {};
    for (let i = 0; i < result.length; i++) {
        objectResult[result[i][0]] = Math.round(result[i][1] / total * 100) / 100;
        if (getTeamIds().includes(result[i][0])) {
            myContribution += objectResult[result[i][0]];
        }
    }

    show_json(myContribution);
    show_json(objectResult);
}


==
Here's some good game goals I've been through this month

1) Get 3 characters running. (in browser/steam or using start_character(name)). Kill mobs for gold/xp until lvl 30+.
Implement something like a farm(mobname) method. 
2) Create a merchant character. Code up the ability to upgrade "shop items". E.g. "buy from the store and upgrade to lvl X". The goal is to get all shop items for all 3 characters to level 7, with their appropriate stat upgrades. There is a trick about stat upgrade pricing. 
2.5) Implement a gui for manual controls. I automated "compound", "upgrade", and "give me all your items".
3) (all lvl7 gear achieved). Now automate fighting harder monsters, bats then Ghosts. These will give earrings and amulet gear. You'll need to implement healing and tanking. (or kiting or some other basic party tactic). Farm up earrings and amulets.
4) Implement more merchant code, GUI controls, automatic potion refills, auto-selling, some way to command that other characters give all their items. 
5) Fix up the codebase to prepare for some "real code". I.e. get linting in place, plan some mission/statetree logic, objective functions for targeting..
6) iuno let me know if you get ahead :D


===

for the angle, you could do something like
const mobAngle = Math.atan2(character.y-target.y, character.x-target.x);
const angle_speed = character.speed/r * 0.25; // 0.25 assuming is't a 250 ms loop

x = h + r*Math.cos(mobAngle+angle_speed);
y = k + r*Math.sin(mobAngle+angle_speed);

==

class TrashCompoundMission {
  constructor() {
    let name = "TrashCompound";
  }

  run() {
    setTimeout( this.cancel(), 10000 );
  }

  cancel() {
    console.log("cancelled");
  }
}
let foo = new TrashCompoundMission();
foo.run();

===


==
Here's some good game goals I've been through this month

1) Get 3 characters running. (in browser/steam or using start_character(name)). Kill mobs for gold/xp until lvl 30+.
Implement something like a farm(mobname) method. 
2) Create a merchant character. Code up the ability to upgrade "shop items". E.g. "buy from the store and upgrade to lvl X". The goal is to get all shop items for all 3 characters to level 7, with their appropriate stat upgrades. There is a trick about stat upgrade pricing. 
2.5) Implement a gui for manual controls. I automated "compound", "upgrade", and "give me all your items".
3) (all lvl7 gear achieved). Now automate fighting harder monsters, bats then Ghosts. These will give earrings and amulet gear. You'll need to implement healing and tanking. (or kiting or some other basic party tactic). Farm up earrings and amulets.
4) Implement more merchant code, GUI controls, automatic potion refills, auto-selling, some way to command that other characters give all their items. 
5) Fix up the codebase to prepare for some "real code". I.e. get linting in place, plan some mission/statetree logic, objective functions for targeting..
6) iuno let me know if you get ahead :D


===

for the angle, you could do something like
const mobAngle = Math.atan2(character.y-target.y, character.x-target.x);
const angle_speed = character.speed/r * 0.25; // 0.25 assuming is't a 250 ms loop

x = h + r*Math.cos(mobAngle+angle_speed);
y = k + r*Math.sin(mobAngle+angle_speed);

==

class TrashCompoundMission {
  constructor() {
    let name = "TrashCompound";
  }

  run() {
    setTimeout( this.cancel(), 10000 );
  }

  cancel() {
    console.log("cancelled");
  }
}
let foo = new TrashCompoundMission();
foo.run();

===

function runtimetest() {
    let start = Date.now();
    let count = 100 * 1000000; // 100 million
    let i = 0;
    for (; i<count; i++) {
        let foo = ["name1","name2","name3"];
    }
    let runtime_ms = Date.now()-start;
    let runtime_sec = runtime_ms/1000;
    console.log(`Runtime for ${count} array creations: ${runtime_ms}ms`);
    console.log(`Runtime for ${count} array creations: ${runtime_sec} seconds`);

    return 1;
    try {
        console.log('trying');
    } catch(err) {
        console.log(err);
    }
}
runtimetest()

===
stand stall 
function open_booth(){
    parent.socket.emit("merchant",{num:0})
}

function close_booth(){
    parent.socket.emit("merchant",{close:1})
}

==
C:\Users\kirkp\AppData\Roaming\Adventure Land\autosync4984500319158272\adventureland\codes>

node "C:\\Users\\kirkp\\AppData\\Roaming\\Sublime Text\\Packages\\ESLint\\linter.js" "C:\\Users\\kirkp\\AppData\\Roaming\\Adventure Land\\autosync4984500319158272\\adventureland\\codes\\farming.15.js" "" ""
WORKS

Error: Cannot find module 'eslint'  SOLUTION: install eslint locally in that folder via `eslint --init`

node "C:\\Users\\kirkp\\AppData\\Roaming\\Sublime Text\\Packages\\ESLint\\linter.js" "'"C:\\Users\\kirkp\\AppData\\Roaming\\Adventure Land\\autosync4984500319158272\\adventureland\\.eslintrc.json" "" ""

===

function bleargh()
{
  var b = "";
  b += "<div style='background-color: black; border: 5px solid gray; padding: 14px; font-size: 24px; display: inline-block; max-width: 640px'>";
  b += "<div style='padding: 10px; color: #CC863B; text-align: center'>Work in Progress</div>";
  "ranger rogue warrior mage priest paladin merchant".split(" ").forEach(function(a) {
    b += "<div>" + a.toTitleCase() + "</div>";
    parent.object_sort(G.skills).forEach(function(c) {
      let ident = c[0];
      c = c[1];
      c["class"] && c["class"].includes(a) && (b += parent.item_container({
        skin: c.skin,
        onclick: bloop_test(ident)
      }))
    })
  });
  b += "<div>Item Skills</div>";
  parent.object_sort(G.skills).forEach(function(a) {
    let ident = a[0];
    a = a[1];
    a.slot && (b += parent.item_container({
      skin: a.skin,
      onclick: bloop_test(ident)
    }))
  });
  b += "<div>Abilities and Utilities</div>";
  parent.object_sort(G.skills).forEach(function(a) {
    let ident = a[0];
    a = a[1];
    if ("ability" == a.type || "utility" == a.type) b += parent.item_container({
      skin: a.skin,
      onclick: bloop_test(ident)
    })
  });
  b += "</div>";
  parent.show_modal(b, {
    wrap: !1,
    hideinbackground: !0,
    url: "/docs/guide/all/skills_and_conditions"
  })
}


function bloop_test(skill)
{
  return "show_modal('<div id=\\'al_skill_preview\\' style=\\'width: 480px\\'></div>', {wrap: !1,hideinbackground: !0,});render_skill('#al_skill_preview', '"+skill+"');"
}

===
let foo = find_npc("newupgrade");
show_json(distance(character, foo))

==
let mons_with_buff = [];
let mon_names_with_cbuff = []
for (let [_mob_id, mob_obj] of Object.entries(G.monsters)) {
    if ("cbuff" in mob_obj) {
        mons_with_buff.push(mob_obj);
    }
}
for (let mob_obj of mons_with_buff) {
    mon_names_with_cbuff.push(mob_obj.name);
    delete mob_obj.achievements;
}
show_json(mons_with_buff);
show_json(mon_names_with_cbuff);


==
let items_with_speed = [];
for (let [itemname, item_obj] of Object.entries(G.items)) {
    if ("speed" in item_obj) {
        items_with_speed.push(item_obj);
    }
}
show_json(items_with_speed);

var filtered = Object.keys(Gitems).reduce(function (filtered, key) {
    if (Gitems[key] > 1) filtered[key] = dict[key];
    return filtered;
}, {});

==
here, have the info I've managed to put together regarding doors since there's not much in the way of info in game on them
/*
door[0] is x coord
door[1] is y coord
door[2] unknown(door width?)
door[3] unknown(door height?)
door[4] map it leads to
door[5] the spawns index for the map being gone to
door[6] the spawns index for this door on this map

spawn[0] is x coord
spawn[1] is y coord
spawn[2] is direction set when spawning at this place (i.e. when moving through a door, characters direction is set based on the destination spawn's direction)
  0/undefined = down
  1 = left
  2 = right
  3 = up
*/

===


let items_with_speed = [];
for (let [itemname, item_obj] of Object.entries(G.items)) {
    if ("speed" in item_obj && item_obj["speed"] > 0) {
        let small_item = {};

        let itemtype = item_obj["type"];

        if (!itemtype in small_item) {
            small_item[itemtype] = [];
        }
        
        let attrs = ["name", "speed", "type", "id"];
        for (let attr of attrs) {
            if (attr in item_obj) {
                small_item[attr] = item_obj[attr];
            }
        }

        items_with_speed.push(small_item);
    }
}
//show_json(items_with_speed);

let by_type = {};
for (let item of items_with_speed) {
    if (!(item.type in by_type)) by_type[item.type] = [];
    by_type[item.type].push( item );
    delete item.type;
}
show_json(by_type);

==


Luck modifiers apply based on the person the monster was targetting when it died, or the character who one-shot it. 

Gold modifiers apply based on the person who opened the chest. 

Every character in party benefits from the party having a specific looter and specific luck user (usually tank)


== FISHING EXAMPLES
one:
let STATE = "guard";
function state_detector() {
    if(can_use("fishing")) {
        STATE = "fishing";
    } else if(can_use("mining")) {
        STATE = "mining";
    } else {
        STATE = "guard";
    }
}
function move_to(location, callback) {
    if (
        can_move_to(location.x, location.y) &&
        distance_to_point(location.x, location.y) > 1 &&
        character.map == location.map
    ) {
        move(location.x, location.y);
    } else if (
        !smart.moving &&
        distance_to_point(location.x, location.y) > 1
    ) {
        smart_move(location);
    }
    if(character.map == location.map && distance_to_point(location.x, location.y) < 1) {
        callback?.();
    }
}
function ensure_equipped(item_name) {
    if(character.slots.mainhand?.name != item_name) {
        let index = get_index_of_item(item_name);
        equip(index);
    }
} 
function go_fishing() {
    if(!character.c.fishing) {
        use_skill("fishing");
    }
}
function go_mining() {
    if(!character.c.mining) {
        use_skill("mining");
    }
}
setInterval(state_detector, 1000);
const guard_location = { x: -500, y: -1415, map: "desertland" };
const fishing_location = { x: -1365, y: -15, map: "main" };
const mining_location = { x: -265, y: -35, map: "tunnel" };
setInterval(() => {
    if (!banking) {
        switch(STATE) {
            case "guard":
                ensure_equipped("vstaff");
                move_to(guard_location);
                break;
            case "fishing":
                ensure_equipped("rod");
                move_to(fishing_location, go_fishing);
                break;
            case "mining":
                ensure_equipped("pickaxe");
                move_to(mining_location, go_mining);
                break;
        }
    }
}, 1000);

TWO: 
export async function goFishing(bot: Merchant): Promise<void> {
    if (!bot.canUse("fishing", { ignoreEquipped: true })) return
    if (!bot.hasItem("rod") && !bot.isEquipped("rod")) return // We don't have a rod

    bot.closeMerchantStand()
    await bot.smartMove(mainFishingSpot) // Move to fishing sppot

    // Equip fishing rod if we don't have it already equipped
    const mainhand = bot.slots.mainhand?.name
    let mainhandSlot: number
    const offhand = bot.slots.offhand?.name
    let offhandSlot: number
    if (!bot.isEquipped("rod")) {
        const promises: Promise<unknown>[] = []
        if (offhand) promises.push(bot.unequip("offhand").then((i) => { offhandSlot = i }))
        mainhandSlot = bot.locateItem("rod", bot.items)
        promises.push(bot.equip(mainhandSlot))
        await Promise.all(promises)
    }

    await bot.fish()

    // Re-equip if we changed weapons
    const promises: Promise<unknown>[] = []
    if (bot.slots.mainhand?.name !== mainhand) {
        if (mainhandSlot !== undefined) promises.push(bot.equip(mainhandSlot, "mainhand"))
    }
    if (bot.slots.offhand?.name !== offhand) {
        if (offhandSlot !== undefined) promises.push(bot.equip(offhandSlot, "offhand"))
    }
    await Promise.all(promises)
}

==
LOOT ALL CHESTS 

let i = 0;
let limit = 25; // max at once (avoid 200 per second code cost)
for (const [key, value] of Object.entries(parent.chests)) {
  loot(key);
    i++;
    if (i>limit) break;
}


==
Promise example:
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    //resolve('foo');
    reject('bar');
  }, 300);
});

promise1
  .then((value) => { console.log(value); })
  .catch((value) => { console.log(value); });


console.log(promise1);
// expected output: [object Promise]



===

have multiple warriors stun them and only attack them while stunned using jacko when stun runs out
you can solo any monster that is not immune to stun that way regardless of stats
==
  socket.on('start',function(data){
        // alert(JSON.stringify(data));
        if(!no_html)
        {
            $("#progressui").remove();
            $("#content").html("");
            $("#topmid,#bottommid,#toprightcorner,#bottomleftcorner2,#bottomleftcorner").show();
            $(".xpsui").css("display","block");
            $(".tutorialui").css("display","block");
            $("body").append('<input id="chatinput" onkeypress="if(event.keyCode==13) say($(this).rfval()); send_typing();" type="text" autocomplete="off" name="alchatinput" placeholder=""/>');
        }

    UI menu controls 
         // locate menu
          const topRightCorner = parent.document.getElementById("toprightcorner");
          if (!topRightCorner) {
            game_log("Cannot find top right corner menu");
            return;
          }

          // Find code button
          const gameButtons = topRightCorner.getElementsByClassName("gamebutton");
          let codeButton;

          for (const gameButton of gameButtons) {
            if (gameButton.innerText === "CODE") {
              codeButton = gameButton;
              break;
            }
          }

          // Create new button
          const aiButton = parent.document.createElement("div");
          aiButton.className = "gamebutton";
          aiButton.appendChild(parent.document.createTextNode("AI \uD83E\uDD16"));
          aiButton.id = "aiuibutton";
          aiButton.setAttribute("onclick", "");

          // Add button
          topRightCorner.insertBefore(aiButton, codeButton);
          topRightCorner.insertBefore(
            parent.document.createTextNode("\n\t\t\t"),
            codeButton
          );

          // Create event
          aiButton.onclick = showAiDialog;
        that onclick attribute that is added is just for css rule :p
        function showAiDialog() {
          parent.show_modal(
            `<div id="modal-ai-settings"><h1>Ai settings<h1>${getAiDialogContent()}</div>`
          );
        }
        forget that manual code editing to update the bot :smile:
        checkbox:
                optionsContent += `
                    <li>
                        <label>
                            <input type="checkbox"${
                              settings[settingType] && " checked"
                            } onchange="code_eval(\`set('${settingType}', \${this.checked})\`)" />
                            ${settingType}
                        </label>
                    </li>
                    `;



==

Ok, i really should have looked in the character reference at some point. I just found out about character.xrange, .esize, .targets(which i always calculated myself) and character.cc, which i think are all useful to know about
===
SpadarFaar — 09/06/2020
If you want rare/valuable equipment, you need to go ranger mage unless you want fiery stuff
[1:47 PM]
Then just mage
[1:48 PM]
If you want gold you have a pretty limited set of monsters to choose from and they're pretty generic except for ents where you need to tank
[1:48 PM]
We don't really have any sources of equipment that can utilize diverse parties
[1:50 PM]
Armor/weapon boxes - cgoos

Book of secrets/agile quiver/fury - rats

Sucker punches - tiny crabs

==
For Devltools: filter these out to clean up consoleLog
-returning -_use -cooldown -Instant -bestiary

How can we get access to the parent object of the methods in runner_functions.js? 
I want to wrap some of those methods with cache helpers, to do things like cache the bank in localstorage.  These methods aren't stored on window or some places under it that I manually explored.

parent.$("#maincode")[0].contentWindow

parent.socket.emit
    socket.emit=function(packet){
        var is_transport=in_arr(arguments && arguments["0"],["transport","enter","leave"]);
        // if(is_transport) alert("transport intercepted");
        if(mode.log_calls) console.log('CALL',JSON.stringify(arguments)+" "+new Date());
        if(!(transporting && is_transport && ssince(transporting)<8))
        {
            original_emit.apply(socket,arguments);
            if(is_transport) transporting=new Date();
        }
    };


==
monster targeting 

function get_weight(current_entity,priority_list,reference){
  let index = priority_list ? Math.max(priority_list.indexOf(current_entity.mtype),0) : 10
  let weight = distance(reference,current_entity)/100
  + Math.min(current_entity.hp/current_entity.max_hp, 0.9)
  + index*100
  return weight
}

==
Cute bee info
{
    "x": -34.826582662967894,
    "y": 167.05867344198663,
    "width": 26,
    "height": 34,
    "alpha": 1,
    "visible": true,
    "cskin": "13",
    "i": 1,
    "j": 3,
    "skin": "cutebee",
    "stype": "full",
    "updates": 638,
    "type": "monster",
    "mtype": "cutebee",
    "in": "main",
    "map": "main",
    "hp": 300,
    "max_hp": 300,
    "mp": 2,
    "max_mp": 15,
    "speed": 12,
    "xp": 400,
    "attack": 16,
    "frequency": 0.5,
    "rage": 0.1,
    "aggro": 1,
    "damage_type": "physical",
    "respawn": -1,
    "range": 20,
    "name": "Cute Bee",
    "armor": 0,
    "resistance": 0,
    "id": "41472980",
    "move_num": 89285877,
    "cid": 1,
    "s": {},
    "last_ms": "2021-09-27T20:59:16.841Z",
    "walking": 31,
    "fx": {},
    "emblems": {},
    "c": {},
    "real_alpha": 1,
    "real_x": -34.826582662967894,
    "real_y": 167.05867344198663,
    "vx": 0,
    "vy": -11.999999984399999,
    "level": 1,
    "base": {
        "h": 12,
        "v": 8.5,
        "vn": 2
    },
    "drawn": true,
    "resync": false,
    "engaged_move": 89285877,
    "moving": true,
    "abs": false,
    "from_x": -34.826582662967894,
    "from_y": 226.91467336417554,
    "going_x": -34.826582662967894,
    "going_y": 26.914673364175542,
    "ref_speed": 12,
    "angle": -90,
    "hp_width": 28,
    "hp_color": 11609895,
    "ms_walk": "2021-09-27T20:59:16.525Z",
    "a_direction": 3,
    "direction": 3
}

==
https://discord.com/channels/238332476743745536/238366540091621377/838500502043492414

logger in use
        let log_message = new GoldLootedLog(character.name, Math.round(Date.now() * 1000000), data.gold)
        logger(log_message)


logging class

export class GoldLootedLog extends CharacterLogMessage {
    public type_name: string = 'gold_looted'
    public amount: number
    constructor(character_name: string, timestamp: number, amount: number) {
        super(character_name, timestamp)
        this.amount = amount
    }

    to_influx_protocol(): string {
        return `${this.type_name},character="${this.character_name}" amount=${this.amount} ${this.timestamp}`
    }
}
class CharacterLogMessage {
    public character_name: string
    public timestamp: number // Date.now() * 1000000

    constructor(character_name: string, timestamp: number) {
        this.character_name = character_name
        this.timestamp = timestamp
    }

    to_influx_protocol(): string {
        return ``
    }
}


== For banking library

/* Bank Slot Guide
A1:Jane      | items6
A2:Christie  | items4
A3:Christina | items5
A4:Janet     | items7
B1:Ledia     | items2
B2:Gabrielle | items0
B3:Gabriella | items1
B4:Lidia     | items3
*/



6  |  4  |  5  |  7
---------------
2  |  0  |  1  |  3


so like since the physical bank tabs look like this

0 1 2 3
4 5 6 7

and you first start with 5 & 6 already open, 
but say you purchase #4, then that would become items3 i believe

so instead of it being 

items0, items1, items2, items3
items4, items5, items6, items7

it would actually be depending on the order you buy something like this

items7, items6, items5, items2
items3, items0, items1, items4


==
https://adventure.land/docs/ref/dungeon-crypt


Future Crypt issues:

There's some issue in the crypt where characters leaving the crypt will still be visible there. I can still see them in parent.entities. Happened on disconnect and also just now after killing a1.

Dre4mc4tcher — 02/23/2021
Regardless the new dungeon is awesome didn't have so much fun in a while after wiping like 20 or more times the Crypt is cleared :slight_smile: The new monsters are really cool the one I found most dangerous was Orlok his zappers are very powerful. It took me some time to understand how to get around Elenas ability. Some monsters can be kited freeze is nice to have. I did the movement manually im pretty sure othervise i would have died even more.


==

 protected async infoLoop(): Promise<void> {
        // Add info about ourselves
        const party: PartyInfo = getPartyInfo()
        party[character.name] = {
            "lastSeen": new Date(),
            "shouldSwitchServer": this.shouldSwitchServer(),
            "monsterHuntTargets": this.getMonsterHuntTargets(),
            "items": getInventory(),
            "attack": character.attack,
            "frequency": character.frequency,
            "goldm": character.goldm,
            "last_ms": character.last_ms,
            "luckm": character.luckm,
            "map": character.map,
            "x": character.real_x,
            "y": character.real_y,
            "s": character.s
        }
        setPartyInfo(party)


add_bottom_button("movement", "Movement", () => { this.holdPosition = !this.holdPosition });


==
Movement

don't use parent.character, use character. parent.character.x is the characters position within the game window, while character.x is the characters position within the map.


I would use an object to represent the coordinate to walk to. So maybe something like this
coords_to_visit.push({map: char.map, x: char.x, y: char.y});
Then you just pass the object to smart_move
smart_move(coord);


The characters in charlist are smart_movable.
You can smart_move(charlist[0]).

==
localStorage notes
All CODE-set keys will be prepended with "c_store"

Examples: 
Object.keys(localStorage) 
14: "cstore_stats_bestiary"
18: "cstore_give_items_Terazarrior"

function localStorageALCacheSize() {
    var allStrings = '';
    let c_keys = Object.keys(localStorage).filter(x => x.slice(0,7) == "cstore_");
    for (let cache_key of c_keys) {
        if(window.localStorage.hasOwnProperty(cache_key)){
            allStrings += window.localStorage[cache_key];
        }
    }
    return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
}
localStorageALCacheSize();

function localStorageALCacheSizeByKey() {
    var allStrings = '';
    let c_keys = Object.keys(localStorage).filter(x => x.slice(0,7) == "cstore_");
    for (let key of c_keys) {
        if(window.localStorage.hasOwnProperty(key)){
            let cstring = window.localStorage[key];
            allStrings += cstring;

            let stringkb = 3 + ((cstring.length*16)/(8*1024));
            console.log(`${key}: ${stringkb} KB`)
        }
    }
    return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
}
localStorageALCacheSizeByKey();

var localStorageSpace = function(){
    var allStrings = '';
    for(var key in window.localStorage){
        if(window.localStorage.hasOwnProperty(key)){
            allStrings += window.localStorage[key];
        }
    }
    return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
};
localStorageSpace();
==


for (key in {1:"one",2:"two"}) console.log(key)
=>  1, 2

==
let key = "test";
if (!get(key)) { set(key, {})};
show_json(get(key))
==
buy from monster hunter

exchange_buy("monstertoken","tracker")

==
parent.next_skill shows when Cooldowns fade for all skills.

== giveaway

function joinGiveAways(){
  for(let id in parent.entities)
    {
        let entity = parent.entities[id];
        if(entity.id != character.id)
        {
            for(let slot_name in entity.slots)
            {
                let slot = entity.slots[slot_name];
                if(slot && slot.giveaway)
                {
                    if(!slot.list.includes(character.id))
                    {
                        parent.join_giveaway(slot_name,entity.id,slot.rid);
                    }
                }
            }
        }
    }
}
joinGiveAways()


===
function sort_inventory() {
    var moveStuff = {
        'mpot0': 1,
        'goldbooster': 0,
        'luckbooster': 0,
        'xpbooster': 0,
    };
    for (var i = 0; i < 42; i++) {
        var item = character.items[i];
        if (item && Object.keys(moveStuff).includes(item.name)) {
            parent.socket.emit("imove", {
                a: i, 
                b: moveStuff[item.name]
        }
    }
}

==

FPS issues
Tried:
- Disable Nvidia overlay (geforce experience settings)
- Disable Discord game overlay
- Turn off Curseforge/Overworlf ()
- Turn off Windows10 Xbox Game Bar (windows "graphics settings")


===
show_json(get_nearest_monster({'type':'phoenix'}))
// smart_move(get_nearest_monster({'type':'phoenix'}))
===
game_log('run_once')
==
start_character("Terranger","default");
start_character("NoHeals4U","default");

start_character("Terranger","Terranger");
start_character("NoHeals4U","NoHeals4U");
stop_character("Terranger");
stop_character("NoHeals4U");
----
	parent.upgrade(locate_item("helmet"), locate_item("scroll0"), null, true, true).then(e=>show_json(e));


===
set("bank-"+character.name, character.bank)
show_json(get("bank-"+character.name))

====
show_json(distance(character, get_player("CurvyMoney"), false))


===FPS convo
https://discord.com/channels/238332476743745536/247016485812174848/721746281021833326
var start=new Date()
localStorage.setItem("test","1")
for(var i=0;i<100;i++)
{
  //game_log(i);
    //for(var key in localStorage){}
    Object.keys(localStorage).forEach(function(key){
    var foo = get(key);
    });
}
output=mssince(start);
show_json(output)

== REQUEST ITEM MANUALLS 

function request_item_from_all(itemname) {
  for (char of ["Terazarrior","NoHeals4U","Terranger"]) {
    var key = "give_items_"+char;
    var items = get(key);
    if (!items.includes(itemname)) {
      items.push(itemname);
    }
    set(key, items);
  }
}

request_item_from_all("hpamulet");
show_json(get("give_items_Terazarrior"));
====



GET ALL FROM BANK 

show_json(character.bank)

function locate_items(name) {
  idxs = [];
  for(var i=0;i<42;i++) {
    if(character.items[i] 
      && character.items[i].name==name) {
      idxs.push(i);
    }
  }
  return idxs;
}
var items = locate_items("stringer");
for (i of items) { bank_retrieve(i); }










parent.upgrade takes the same parameters as upgrade. But it supports two more. One that I don't remember exactly what did (left it as true) and the last parameter is for calculate

   socket.emit('upgrade', {
          item_num,
          scroll_num,
          offering_num: null,
          clevel,
          calculate: false,
        });


   socket.emit('compound', {
        items,
        scroll_num,
        offering_num: null,
        clevel,
        calculate: true
      });
  let results = push_deferred('compound');

  socket.emit('upgrade', {
        item_num,
        scroll_num,
        offering_num: null,
        clevel,
        calculate: true,
      });
  let results = push_deferred('upgrade');


parent.upgrade(slot_item, slot_scroll, offering, "code", calculate);

returns a promise. you can either use  .then/.catch on it or if you use async/await you can just const result =  await parent.upgrade(

  ==
  ACtion skills

  use_skill('blink', [x, y]);

  ===
  let testing=false;
let angle=0;
let radius=100;

//point to circle arround
let centerX=-0;
let centerY=0;

let lastMove = 0;
setInterval(function(){
        clear_drawings();
        draw_circle(centerX, centerY, radius);
        let nextX = centerX + Math.cos(angle)*radius;
        let nextY = centerY + Math.sin(angle)*radius;
    
        if(distance({x: nextX, y: nextY}, character) < 30)
        {
            angle += 0.1;
        }
        
        draw_line(centerX, centerY, nextX, nextY);
    
        if(!character.moving && new Date() - lastMove > 100)
        {
            xmove(nextX,nextY);
            lastMove = new Date();
        }
}, 10);


==


Kite visualizer
var draw_debug = true;

function on_draw(){
  if(draw_debug){
      clear_drawings();

      draw_circle(character.real_x, character.real_y, character.range);

      var target = get_target(character);
      if(target){
          draw_line(character.real_x, character.real_y, target.x, target.y);
      }
      if(is_moving(character)){
          draw_line(character.from_x, character.from_y, character.going_x, character.going_y, 1, 0x33FF42);
      }
    }

    for(id in parent.entities){
      var entity = parent.entities[id];
      var entity_targ = get_target_of(entity);
      if(entity_targ && entity_targ.name === character.name && entity.moving){
        draw_line(entity.from_x, entity.from_y, entity.going_x, entity.going_y, 1, 0xda0b04);
        draw_circle(entity.x, entity.y, entity.range, 1, 0xda0b04);
      }
    }
}
